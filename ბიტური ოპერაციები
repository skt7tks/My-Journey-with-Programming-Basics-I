## ბიტური ოპერაციები
ბიტი წარმოადგენს ინფორმაციის უმცირეს ერთეულს, რომელიც კომპიუტერის მიერ ინახება. მისი მნიშვნელობა 0 ან 1–ია. ჩვენს მიერ პროგრამაში მითითებული ნებისმიერი გამოთვლა შესრულებისას ბიტების დონეზე ხდება ორობით სისტემაში (იხილე თავი ???). ამის გამო თითქმის ყველა პროგრამულ ენაში არსებობს ბრძანებები, რომლებიც საშუალებას აძლევენ პროგრამისტს იმოქმედოს უშუალოდ ბიტებზე. ზოგ შემთხვევაში ეს იძლევა მოგებას პროგრამის სწრაფქმედების თვალსაზრისით, ზოგჯერ კი საშუალებას იძლევა კომპაქტურად შევინახოთ მონაცემები და დავზოგოთ მეხსიერება.
ყველაზე მარტივ ბიტურ ოპერაციას წარმოადგენს წანაცვლება, რომელიც სრულდება როგორც მარჯვნივ, ასევე მარცხნივ. მაგალითად, int a=53 ცვლადი მეხსიერებაში შენახულია, როგორც 00000000000000000000000000110101. მარცხნივ ერთი ერთეულით წანაცვლება გულისხმობს, რომ ყველაზე მარცხენა ბიტი დაიკარგება, დანარჩენი 63 ბიტი გადაიწევს თითო პოზიციით მარცხნივ, ხოლო ბოლოში რიცხვს მიეწერება ნულიანი. მივიღებთ: 00000000000000000000000001101010, რაც ათობით სისტემაში 106–ს უდრის. ადვილი მისახვედრია, რომ მარცხნივ ერთი ერთეულით წანაცვლება ცვლადის მნიშვნელობას 2–ჯერ გაზრდის. ანალოგიურად, ორჯერ შეამცირებს რიცხვს მარჯვნივ წანაცვლება, რომლის დროსაც იკარგება განაპირა მარჯვენა ბიტი, დანარჩენი 63 ბიტი გადაიწევს თითო პოზიციით მარჯვნივ, ხოლო თავში რიცხვს მიეწერება ნულიანი. int a=53–ისათვის, მივიღებთ: 00000000000000000000000000011010, რაც ათობით სისტემაში 26–ის ტოლია, ანუ შესრულდა მთელი გაყოფა 2–ზე. აქვე შევნიშნოთ, რომ ოპერაცია a=a<<1 პროცესორის მიერ გაცილებით სწრაფად სრულდება, ვიდრე a=a*2;

# ბიტური ოპერაციების ცხრილი

ოპერაციის სიმბოლო     ოპერაციის მნიშვნელობა                 გამოყენების წესი
--------------------  ------------------------------------  ----------------------
~                    ბიტური „უარყოფა“ (NOT)                ~expr
<<                   წანაცვლება მარცხნივ                   expr1 << expr2
>>                   წანაცვლება მარჯვნივ                   expr1 >> expr2
&                    ბიტური „და“ (AND)                     expr1 & expr2
^                    ბიტური „გამომრიცხავი ან“ (XOR)        expr1 ^ expr2
|                    ბიტური „ან“ (OR)                      expr1 | expr2
&=                   ბიტური „და“ მინიჭებით                 expr1 &= expr2
^=                   ბიტური „გამომრიცხავი ან“ მინიჭებით    expr1 ^= expr2
|=                   ბიტური „ან“ მინიჭებით                 expr1 |= expr2
<<=                  წანაცვლება მარცხნივ მინიჭებით         expr1 <<= expr2
>>=                  წანაცვლება მარჯვნივ მინიჭებით         expr1 >>= expr2


ბიტური „უარყოფა“ცვლის ოპერანდის ყველა ბიტის მნიშვნელობას საპირისპიროთი. ბიტი, რომლის მნიშვნელობაც 0–ია, იცვლება 1–ით, და პირიქით, ბიტი, რომლის მნიშვნელობაც 1–ია, იცვლება 0–ით.

ბიტური „და“ (&) სრულდება ორი ოპერანდისათვის. მარცხენა ოპერანდის ყოველი ბიტი ედარება მარჯვენა ოპერანდის იმავე პოზიციაში მდგომ ბიტს და თუ ორივე ბიტი 1–ის ტოლია, მაშინ შედეგის შესაბამის
პოზიციაში ბიტი 1–ის ტოლია, ხოლო წინააღმდეგ შემთხვევაში – 0. მაგალითად, 53&44=36, რადგან 5310=1101012 და 4410=1011002, ხოლო 1–იანები ემთხვევა მხოლოდ მარჯვნიდან მესამე და მეექვსე პოზიციებში,
ამიტომ შედეგი იქნება 1001002=3610. 

ბიტური „ან“ (|) შედეგში წერს 1–ს, თუ შესაბამის პოზიციაში ერთ–ერთ ოპერანდს მაინც აქვს 1, ხოლო 0–ს მხოლოდ მაშინ წერს, თუკი ორივე ოპერანდის ბიტი შესაბამის პოზიციაში 0–ია. მაგალითად, 53|44=62, 
რადგან 5310=1101012 და 4410=1011002, ხოლო 0–იანები ემთხვევა მხოლოდ მარჯვნიდან მეორე პოზიციაში, ამიტომ შედეგი იქნება 1111012=3610.

ბიტური „გამომრიცხავი ან“ (^) შედეგში წერს 1–ს, თუ შესაბამის პოზიციაში ოპერანდებს განსხვავებული ბიტები აქვს, ხოლო წინააღმდეგ შემთხვევაში 0–ს. მაგალითად, 53^44=25, რადგან 5310=1101012 და 4410=1011002,
ხოლო ბიტები ერთნაირია მარჯვნიდან პირველ, მეოთხე და მეხუთე პოზიციებში, ამიტომ შედეგი იქნება 0110012=2510.

## განვიხილოთ მარტივი ამოცანა. 
ვთქვათ, უნდა შევინახოთ ინფორმაცია 30 ლამპიონის მდგომარეობის შესახებ, რომლებიც ერთ მწკრივად არიან განლაგებული. მდგომარეობა ორი სახისაა – ჩართული ან გამორთული. ცხადია, ეს ინფორმაცია შეიძლება შევინახოთ მასივის სახით, სადაც თითო ლამპიონისათვის მეხსიერებაში 1 ბაიტი მაინც იქნება საჭირო, თუ bool ტიპის ცვლადებს გამოვიყენებთ (int–ის გამოყენებისას 4–4 ბაიტი დაგვჭირდებოდა). თუმცა არსებობს უფრო ეფექტური გზაც: რადგან ლამპიონებს სულ 2 მდგომარეობა აქვთ, შეიძლება ისინი აღვნიშნოთ 0–ით (გამორთული) და 1–ით (ჩართული) და ინფორმაცია შევინახოთ თითო ბიტში. სულ დაგვჭირდებოდა 30 ბიტი (ანუ int ტიპის 1 ცვლადი, სადაც მარცხენა 2 ბიტი გამოუყენებელი იქნება, ხოლო მარჯვენა 30 ბიტში იქნება ინფორმაცია ლამპიონების მდგომარეობის შესახებ). ვთქვათ, ლამპიონების საწყისი მდგომარეობაა: 110001010011100101100010111100. თუ ამ ჩანაწერს განვიხილავთ, როგორც int ტიპის ცვლადის ორობით ჩანაწერს, რომელიც მარცხნიდან 2 ნულითაა შევსებული, ათობითში გვექნება რიცხვი x=827218108, ანუ ეს ერთი რიცხვი შეიცავს ინფორმაციას ოცდაათივე ლამპიონის მდგომარეობის შესახებ. შევნიშნოთ, რომ ლამპიონების გადანომვრა ხდება მარჯვნიდან მარცხნივ. 
ცხადია, რომ მხოლოდ ერთი კონკრეტული სიტუაციის შენახვა მასში ცვლილებების გახორციელების გარეშე ბევრს არაფერს მოგვცემდა. თუ საჭიროა, ვთქვათ, 27–ე ლამპიონის მდგომარეობის შეცვლა (საწყის სიტუაციაში 27–ე ლამპიონი ჩამქრალია, ე.ი. უნდა ავანთოთ, რაც იგივეა, რომ მარჯვნიდან 27–ე პოზიციაში 0–ის ნაცვლად 1 ჩავწეროთ), ასე უნდა მოვიქცეთ: ჯერ მივიღოთ რიცხვი, რომლის 27–ე პოზიციაში წერია 1, ხოლო ყველა სხვა ბიტი 0–ის ტოლია. ასეთი რიცხვის მისაღებად გამოვიყენოთ წანაცვლების ოპერაცია: z=1<<27; ახლა კი თუ გამოვიყენებთ „ბიტურ ან“–ს x და z ცვლადების მიმართ x = x|z, მივიღებთ სასურველ შედეგს.
იმ შემთხვევაში, თუ საჭიროა 1–ის შეცვლა 0–ით, ჯერ უნდა მივიღოთ რიცხვი, რომელშიც ჩვენთვის საინტერესო პოზიციაში წერია 0, ხოლო ყველა დანარჩენ ბიტში – 1. იგივე 27–ე პოზიციისათვის ეს ასე მოხდება: z=~(1<<27 ); შემდეგ კი უნდა შევასრულო „ბიტური და“ ამ რიცხვსა და საწყის მდგომარეობას შორის: x = x&z;

